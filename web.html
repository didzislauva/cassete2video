<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Appendix: A Step-by-Step Breakdown of the Conversion Script</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2, h3 {
            color: #333;
        }
        code {
            background: #f4f4f4;
            
            border-radius: 3px;
            padding: 0.2em 0.4em;
            font-family: monospace;
        }
        pre {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 1em;
            overflow-x: auto;
        }
        .note {
            background: #e7f1ff;
            border-left: 5px solid #007bff;
            padding: 0px;
            margin: 0px 0;
        }
    </style>
</head>
<body>
    <h1>Appendix: A Step-by-Step Breakdown of the Conversion Script</h1>

    <p>For those interested in the technical details, here’s an in-depth look at how the script works to convert cassette audio files and images into YouTube-ready videos. This appendix will guide you through each segment of the script, explaining its function and purpose.</p>

    <h2>Script Overview</h2>
    <pre><code>@echo off
setlocal enabledelayedexpansion
</code></pre>
    <p>The script begins with <code>@echo off</code>, which suppresses the command echo, keeping the console output clean. <code>setlocal enabledelayedexpansion</code> is used to enable the use of delayed variable expansion, allowing variables to be updated dynamically within loops and conditionals.</p>

    <h2>User Input</h2>
    <pre><code>:: Prompt user for the key (t for last 10 seconds, a for full MP3)
echo Enter the key (t for last 10 seconds, a for full MP3):
set /p key=

:: Debugging output
echo Key entered: "%key%"

:: Prompt user for the image file path
echo Enter the path to the image file:
set /p image_file=

:: Prompt user for the audio file path
echo Enter the path to the audio file:
set /p audio_file=

:: Prompt user for the output video file name
echo Enter the output video file name:
set /p output_file=
</code></pre>
    <p>The script starts by prompting the user to enter several pieces of information:
        <ul>
            <li><strong>Key</strong>: Determines whether to use the last 10 seconds of audio (<code>t</code>) or the entire file (<code>a</code>).</li>
            <li><strong>Image file path</strong>: Location of the image to be used as a video backdrop.</li>
            <li><strong>Audio file path</strong>: Location of the audio file.</li>
            <li><strong>Output video file name</strong>: Desired name for the resulting video.</li>
        </ul>
    </p>

    <h2>File Existence Check</h2>
    <pre><code>:: Check if the image file exists
if not exist "%image_file%" (
    echo The image file does not exist.
    exit /b 1
)

:: Check if the audio file exists
if not exist "%audio_file%" (
    echo The audio file does not exist.
    exit /b 1
)
</code></pre>
    <p>Before proceeding, the script verifies that both the image and audio files exist. If either file is missing, it displays an error message and exits.</p>

    <h2>Image Width Verification and Cropping</h2>

    <h3>Getting the Image Width</h3>
    <pre><code>:: Get the image width using ffprobe
ffprobe -v error -select_streams v:0 -show_entries stream=width -of default=noprint_wrappers=1:nokey=1 "%image_file%" > width.txt
</code></pre>
    <p>To ensure the image is suitable for video encoding, the script retrieves its width using <code>ffprobe</code>, a companion tool to <code>ffmpeg</code>. Here’s a breakdown of the <code>ffprobe</code> command used:
        <ul>
            <li><code>-v error</code>: Limits output to errors only, reducing clutter.</li>
            <li><code>-select_streams v:0</code>: Chooses the first video stream from the file.</li>
            <li><code>-show_entries stream=width</code>: Extracts the width of the image.</li>
            <li><code>-of default=noprint_wrappers=1:nokey=1</code>: Formats the output to display just the width value without additional text or labels.</li>
        </ul>
    </p>
    <p>The width value is saved to a temporary file (<code>width.txt</code>).</p>

    <h3>Reading and Cleaning Up</h3>
    <pre><code>:: Read the width from the temporary file
set /p width=<width.txt

:: Clean up temporary file
del width.txt
</code></pre>
    <p>The script reads the width from the <code>width.txt</code> file and then deletes the temporary file to clean up. This width value will be used to determine if the image needs to be cropped.</p>

    <h3>Checking the Width</h3>
    <pre><code>:: Check if ffprobe was successful
if "%width%"=="" (
    echo Failed to get the image width.
    pause
    exit /b 1
)

:: Display the width
echo Width: %width%

:: Check if width is divisible by 2
set /a result=width %% 2

if !result! neq 0 (
    echo Width is not divisible by 2
    echo Cropping 1 pixel from the width to make it divisible by 2...
</code></pre>
    <p>If the width value is empty, indicating that <code>ffprobe</code> failed, the script displays an error message and exits. Otherwise, it displays the width and checks if it is divisible by 2. If not, the script proceeds to crop the image.</p>

    <h3>Why Even Width Matters</h3>
    <p>In video encoding, especially with codecs like H.264 used in <code>ffmpeg</code>, many video compression algorithms require the width and height of the video to be divisible by 2. This requirement stems from the way video compression techniques, such as chroma subsampling and block-based compression, process image data. If the width or height is not divisible by 2, it can lead to inefficiencies in compression and potential playback issues. Therefore, ensuring that the image dimensions are even helps maintain compatibility and performance across different video players and platforms.</p>

    <h3>Cropping the Image</h3>
    <pre><code>:: Extract only the filename and extension from the input file
for %%f in ("%image_file%") do (
    set "filename=%%~nf"
    set "extension=%%~xf"
    set "filepath=%%~dpf"
)
</code></pre>
    <p>The <code>for</code> loop extracts the filename, extension, and path from the original image file path. This step is necessary to create a new file name for the cropped image.</p>

    <pre><code>:: Define a temporary output file name in the same directory as the input file
set "cropped_image=!filepath!!filename!_cropped!extension!"

:: Display the file names for debugging
echo Input file: "%image_file%"
echo Output file: "!cropped_image!"
</code></pre>
    <p>The script constructs a new file name for the cropped image by appending <code>_cropped</code> to the original filename. This new file will be saved in the same directory as the original image.</p>

    <pre><code>:: Crop the image to remove 1 pixel from the right
ffmpeg -i "%image_file%" -vf "crop=iw-1:ih:0:0" "!cropped_image!"
</code></pre>
    <p>Using <code>ffmpeg</code>, the script crops the image by removing 1 pixel from the right. Here’s what the <code>ffmpeg</code> command does:
        <ul>
            <li><code>-i "%image_file%"</code>: Specifies the input image file.</li>
            <li><code>-vf "crop=iw-1:ih:0:0"</code>: Applies the crop filter. <code>iw-1</code> reduces the width by 1 pixel, and <code>ih</code> keeps the height unchanged.</li>
        </ul>
    </p>

    <pre><code>:: Check if cropping was successful
if exist "!cropped_image!" (
    echo Image cropped successfully.
    echo Overwriting the original image with the cropped image.
    move /y "!cropped_image!" "%image_file%"
) else (
    echo Failed to crop the image. Check the command and file formats.
    pause
    exit /b 1
)
</code></pre>
    <p>Finally, the script checks if the cropped image was created successfully. If it exists, it replaces the original image with the cropped version. If not, it displays an error message and exits.</p>

    <h2>Video Creation Based on User Input</h2>
    <pre><code>:: Debugging output
echo Input image file: "%image_file%"
echo Audio file: "%audio_file%"
echo Output video file: "%output_file%"

:: Process based on the key
if /i "%key%"=="t" (
    echo Key is 't'
    echo Processing with last 10 seconds of audio...
    ffmpeg -loop 1 -i "%image_file%" -i "%audio_file%" -c:v libx264 -tune stillimage -preset ultrafast -b:v 500k -c:a copy -shortest -r 1 -t 10 "%output_file%"

) else if /i "%key%"=="a" (
    echo Key is 'a'
    echo Processing with full audio...
    ffmpeg -loop 1 -i "%image_file%" -i "%audio_file%" -c:v libx264 -tune stillimage -preset ultrafast -b:v 500k -c:a copy -shortest -r 1 "%output_file%"

) else (
    echo Invalid key. Please enter 't' for last 10 seconds or 'a' for full MP3.
    exit /b 1
)
</code></pre>
    <p><strong>Creating the Video with <code>ffmpeg</code>:</strong></p>
    <pre><code>ffmpeg -loop 1 -i "%image_file%" -i "%audio_file%" -c:v libx264 -tune stillimage -preset ultrafast -b:v 500k -c:a copy -shortest -r 1 -t 10 "%output_file%"
</code></pre>
    <p>This command generates the video file based on the user’s input:
        <ul>
            <li><code>-loop 1</code>: Loops the image for the entire video duration.</li>
            <li><code>-i "%image_file%"</code>: Specifies the input image file.</li>
            <li><code>-i "%audio_file%"</code>: Specifies the input audio file.</li>
            <li><code>-c:v libx264</code>: Uses the H.264 codec for video encoding.</li>
            <li><code>-tune stillimage</code>: Optimizes the encoding for still images.</li>
            <li><code>-preset ultrafast</code>: Sets the encoding speed to ultra-fast, trading off some compression efficiency for speed.</li>
            <li><code>-b:v 500k</code>: Sets the video bitrate to 500 kbps.</li>
            <li><code>-c:a copy</code>: Copies the audio stream without re-encoding.</li>
            <li><code>-shortest</code>: Ensures the video duration matches the shortest input (audio or image).</li>
            <li><code>-r 1</code>: Sets the frame rate to 1 frame per second, which is suitable for static images.</li>
            <li><code>-t 10</code>: Specifies the video duration of 10 seconds, applicable if the key is <code>t</code>.</li>
        </ul>
    </p>
    <p>The <code>-t</code> parameter is used only if the key is <code>t</code>, specifying a video duration of 10 seconds. If the key is <code>a</code>, the <code>-t</code> parameter is omitted, resulting in a video that matches the full length of the audio file.</p>

    <h2>Final Steps</h2>
    <pre><code>endlocal
pause
</code></pre>
    <p>Finally, <code>endlocal</code> restores the previous environment settings, and <code>pause</code> keeps the console window open so the user can review the output messages before it closes.</p>

    <p>This script effectively combines vintage audio and static images into a format that is both preserved and shareable, making it a practical tool for digital archivists and enthusiasts alike.</p>
</body>
</html>
